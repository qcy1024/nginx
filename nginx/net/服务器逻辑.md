为什么需要连接池这种东西保存每一个连接详细的信息？ 因为当epoll对象上某些文件描述符就绪时，我们是需要这个就绪事件的详细信息的。比如：我们需要就绪事件对应的客户端套接字，需要相应的处理函数。而一个连接的指针可以被存放在事件event的event.data.ptr里面。并且就绪事件的处理函数也都需要一个连接的详细信息，而这种详细信息刚好可以被一个“连接对象”的指针保存。



ngx_c_socket.cxx中的ngx_epoll_init()函数在worker进程的初始化函数中被调用。该函数创建了epoll对象、new出了连接池，遍历每一个监听端口类型(其中有fd，port，以及它对应的连接connection。)  并将所有监听端口的套接字描述符加入到了epoll对象中去，并设置它们关心的事件为读事件；并将监听对象和连接对象绑定到一起，并且设置该连接的读事件处理函数rhandler为**ngx_event_accept**;



完成了如上工作之后，当客户端有TCP连接进来的时候，就会触发相应epoll上套接字描述符的读事件就绪；



ngx_c_socket.cxx中的**ngx_epoll_process_events()**函数可以处理客户端来的TCP连接。这个函数在worker进程的死循环里面被调用。这个函数的作用就是调用epoll_wait()取出所有已就绪事件。然后用一个for循环遍历所有就绪事件，取出事件类型和事件的处理函数指针，根据不同的事件类型执行不同的事件处理函数。如果是读事件（EPOLLIN），就执行读处理函数（rhandler）。服务端监听套接字上的读事件处理函数在套接字被加到epoll对象上时被设置为了ngx_event_accept()。



**ngx_event_accept()**函数在ngx_c_socket_accept.cxx里面。这个函数的作用是：当客户端连入到服务器后，为客户端在epoll对象上建立一个对应的项，以及在将这个连接保存在连接池中。具体来说，首先调用了accept接收连接，然后从空闲连接池中取出一项，设置该项的读事件处理函数rhandler为**ngx_wait_request_handler**; 最后将这个客户端的套接字描述符、关心的事件、连接池指针信息(记录的相应事件的处理函数)传入函数ngx_epoll_add_events()，将该客户端套接字描述符加入到epoll对象中去。



至此，epoll对象上就有了两种套接字描述符：
1.服务端监听的套接字描述符；
2.已建立好连接的客户端套接字描述符。
对于1.的读事件，处理函数是ngx_event_accept();
对于2.的读事件，处理函数是ngx_wait_request_handler;







